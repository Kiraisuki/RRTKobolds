package com.kiraisuki.rrtkobolds.entities.ai;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Stack;

import javax.annotation.Nullable;

import com.kiraisuki.rrtkobolds.RRTKobolds;

import net.minecraft.block.BlockDoor;
import net.minecraft.init.Blocks;
import net.minecraft.pathfinding.Path;
import net.minecraft.pathfinding.PathPoint;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.IBlockAccess;;

/**
 * Class that holds a tree generated by RRT and generates a final path for the Minecraft built-in path traverser
 * @author kiraisuki
 *
 */
public class RRTTree
{
	private HashSet<Branch> branches;
	private Branch root, goalBranch;
	private boolean hasSolution;
	private final IBlockAccess blockAccess;
	private final double[] destination;
	private long timeSpentBuildPath, timeClamp, timeNN, timeRasterize, timeCollision;
	
	public RRTTree(PathPoint startLoc, PathPoint endLoc, IBlockAccess iba) 
	{
		double[] start = {startLoc.x, startLoc.y, startLoc.z};
		double[] end = {endLoc.x, endLoc.y, endLoc.z};
		
		root = new Branch(start, start, null, new ArrayList<PathPoint>());
		blockAccess = iba;
		branches = new HashSet<>();
		branches.add(root);
		hasSolution = false;
		destination = end;
		timeSpentBuildPath = 0;
		timeClamp = 0;
		timeNN = 0;
		timeRasterize = 0;
		timeCollision = 0;
	}
	
	public boolean isSolved()
	{
		return hasSolution;
	}
	
	/**
	 * Builds the path for the traverser
	 * @return a finished path, or null
	 */
	@Nullable
	public Path getPath()
	{
		if(!hasSolution)
			return null;
		
		timeSpentBuildPath = System.currentTimeMillis();
		
		Path path;
		
		Stack<ArrayList<PathPoint>> movements = new Stack<>();
		
		Branch current = goalBranch;
		
		//Go through the branches and push their path segments onto a stack
		while(current != null)
		{
			movements.push(current.getPathSegment());
			
			current = current.getParent();
		}
		
		//Go through the rasterized path segments and clean them up before adding them to the main path
		ArrayList<PathPoint> points = new ArrayList<>();
		
		while(!movements.isEmpty())
		{
			ArrayList<PathPoint> movement = movements.pop();
			
			if(movement.isEmpty())
				continue;
			
			PathPoint previous = movement.get(0);
			
			for(PathPoint p : movement)
			{
				if(p.y != previous.y)
					points.add(p);
				
				previous = p;
			}
			
			points.add(movement.get(movement.size() - 1));
		}
		
		//Iterative path shortening
		//Cleans up big spikes in the path to make them more efficient
		ArrayList<PathPoint> finalPath = new ArrayList<>();
		
		for(int i = 0; i < points.size(); i++)
		{
			PathPoint currentPoint = points.get(i);
			finalPath.add(currentPoint);
			
			for(int j = points.size() - 1; j > i; j--)
			{
				PathPoint dest = points.get(j);
				
				ArrayList<PathPoint> rasterized = rasterizePath(currentPoint, dest);
				
				if(isValidPathSegment(rasterized))
				{
					PathPoint previous = rasterized.get(0);
					
					for(PathPoint p : rasterized)
					{
						if(p.y != previous.y || isDoor(new BlockPos(p.x, p.y, p.z)))
							finalPath.add(p);
						
						previous = p;
					}
					
					finalPath.add(rasterized.get(rasterized.size() - 1));
					
					i = j;
				}
			}
		}
		
		//Assemble the final path
		PathPoint[] pts = new PathPoint[finalPath.size()];
		
		RRTKobolds.logger.info("Path length " + finalPath.size());
		
		for(int i = 0; i < finalPath.size(); i++)
			pts[i] = finalPath.get(i);
		
		path = new Path(pts);
		
		timeSpentBuildPath = System.currentTimeMillis() - timeSpentBuildPath;
		
		RRTKobolds.logger.info("Collision: " + timeCollision + 
				" (Avg: " + ((float)timeCollision / (float)branches.size()) +
				") Build Path: " + timeSpentBuildPath +
				" Clamp: " + timeClamp + 
				" (Avg: " + ((float)timeClamp / (float)branches.size()) + ") " +
				"NNS: " + timeNN + " (Avg: " + ((float)timeNN / (float)branches.size()) + ") " +
				"Rasterize: " + timeRasterize + " (Avg: " + ((float)timeRasterize / (float)branches.size()) + ")");
		
		return path;
	}
	
	/**
	 * Checks if a given position is a solid block or not
	 * @param x
	 * @param y
	 * @param z
	 * @return true if yes, false if no
	 */
	private boolean isObstructed(double x, double y, double z)
	{
		BlockPos pos = new BlockPos(x, y, z);
		boolean isAir = blockAccess.isAirBlock(pos);
		boolean isPassable = blockAccess.getBlockState(pos).getBlock().isPassable(blockAccess, pos);
		boolean isDoor = isDoor(pos);
		
		return !(isAir || isPassable) && !isDoor;
	}
	
	private boolean isObstructed(double[] point)
	{
		return isObstructed(point[0], point[1], point[2]);
	}
	
	private boolean isDoor(BlockPos pos)
	{
		return blockAccess.getBlockState(pos).getBlock() instanceof BlockDoor;
	}
	
	/**
	 * Checks if a given point is fire or lava
	 * @param p possible danger point
	 * @return true if hot, false if not
	 */
	private boolean isDanger(PathPoint p)
	{
		BlockPos pos = new BlockPos(p.x, p.y, p.z);
		boolean isFire = blockAccess.getBlockState(pos).getBlock() == Blocks.FIRE;
		boolean isLava = blockAccess.getBlockState(pos).getBlock() == Blocks.FLOWING_LAVA || blockAccess.getBlockState(pos).getBlock() == Blocks.LAVA;
		
		return isFire || isLava;
	}
	
	/**
	 * Returns true if there is more than 3 spaces of air below this block
	 * @param x x of point
	 * @param y y of point
	 * @param z z of point
	 * @return true if there is a hole at (x, y, z), false otherwise
	 */
	private boolean isHole(PathPoint p)
	{
		for(int i = 0; i < 4; i++)
		{
			if(isObstructed(p.x, p.y - i, p.z))
				return false;
		}
		
		return true;
	}
	
	/**
	 * Checks for danger at or below a given position
	 * doesn't check past 4 deep because isHole will have caught that anyway
	 * @param p PathPoint point of potential danger
	 * @return true if danger, false if not
	 */
	private boolean checkForDanger(PathPoint p)
	{
		//Vertical danger
		for(int i = 0; i < 4; i++)
		{
			if(isObstructed(p.x, p.y - i, p.z) && !isDanger(new PathPoint(p.x, p.y - i, p.z)))
				return false;
				
			else if(isDanger(new PathPoint(p.x, p.y - i, p.z)))
				return true;
		}
			
		return false;
	}
	
	/**
	 * Checks all points along a rasterized path for holes, danger, or heights too tall to jump up
	 * @param start double[3] of x, y, z start of line
	 * @param end double[3] of x, y, z end of line
	 * @return true if (x, y, z) is a valid place to move, false otherwise
	 */
	private boolean isValidPathSegment(ArrayList<PathPoint> points)
	{
		PathPoint prev = points.get(0);
		
		for(PathPoint p : points)
		{
			if(isHole(p) || checkForDanger(p) || p.y > prev.y + 1 || p.y < prev.y - 1)
				return false;
			
			prev = p;
		}
		
		return true;
	}
	
	/**
	 * Rasterizes a path into individual (x,y,z) for the traverser
	 * Clamps y values to nearest solid block with empty space above it
	 * 
	 * Bresenham's line rasterizer in 3D
	 * Modified from https://www.mathworks.com/matlabcentral/fileexchange/21057-3d-bresenham-s-line-generation
	 * 
	 * @param start double[3] of x, y, z start of line
	 * @param end double[3] of x, y, z end of line
	 * @return ArrayList<PathPoint> list of all rasterized and y-clamped PathPoint that lie on the line formed by start and end
	 */
	private ArrayList<PathPoint> rasterizePath(int stx, int sty, int stz, int enx, int eny, int enz)
	{
		ArrayList<PathPoint> path = new ArrayList<>();

	    int x1 = stx;
	    int y1 = sty;
	    int z1 = stz;
	    int x2 = enx;
	    int y2 = eny;
	    int z2 = enz;
	    int dx = x2 - x1;
	    int dy = y2 - y1;
	    int dz = z2 - z1;
	    int ax = MathHelper.abs(dx)*2;
	    int ay = MathHelper.abs(dy)*2;
	    int az = MathHelper.abs(dz)*2;
	    int sx = dx >= 0 ? (dx == 0 ? 0 : 1) : -1;
	    int sy = dy >= 0 ? (dy == 0 ? 0 : 1) : -1;
	    int sz = dz >= 0 ? (dz == 0 ? 0 : 1) : -1;
	    int x = x1;
	    int y = y1;
	    int z = z1;
	    
	    if(ax >= Math.max(ay,az))
	    {
	        int yd = ay - ax/2;
	        int zd = az - ax/2;
	        
	        while(true)
	        {
	        	path.add(new PathPoint(x, clampY(x, y, z), z));
	            
	            if(x == x2)
	                break;
	            
	            if(yd >= 0)
	            {
	                y = y + sy;
	                yd = yd - ax;
	            }
	            
	            if(zd >= 0)
	            {
	                z = z + sz;
	                zd = zd - ax;
	                
	                path.add(new PathPoint(x, clampY(x, y, z), z));
	            }
	            x  = x  + sx;
	            yd = yd + ay;
	            zd = zd + az;
	        }
	    }
	    
	    else if(ay >= Math.max(ax,az))
	    {
	        int xd = ax - ay/2;
	        int zd = az - ay/2;
	        
	        while(true)
	        {
	        	path.add(new PathPoint(x, clampY(x, y, z), z));
	            
	            if(y == y2)
	                break;

	            if(xd >= 0)
	            {
	                x = x + sx;
	                xd = xd - ay;
	            }
	            
	            if(zd >= 0)
	            {
	                z = z + sz;
	                zd = zd - ay;
	            }

	            y  = y  + sy;
	            xd = xd + ax;
	            zd = zd + az;
	        }
	    }
	    
	    else if(az >= Math.max(ax,ay))
	    {
	        int xd = ax - az/2;
	        int yd = ay - az/2;
	        while(true)
	        {
	        	path.add(new PathPoint(x, clampY(x, y, z), z));
	            
	            if(z == z2)
	                break;

	            if(xd >= 0)
	            {
	                x = x + sx;
	                xd = xd - az;
	                path.add(new PathPoint(x, clampY(x, y, z), z));
	            }

	            if(yd >= 0)
	            {
	                y = y + sy;
	                yd = yd - az;
	            }

	            z  = z  + sz;
	            xd = xd + ax;
	            yd = yd + ay;
	        }
	    }
	    
	    return path;
	}
	
	/**
	 * Rasterizes a path into individual (x,y,z) for the traverser
	 * Clamps y values to nearest solid block with empty space above it
	 * 
	 * Bresenham's line rasterizer in 3D
	 * Modified from https://www.mathworks.com/matlabcentral/fileexchange/21057-3d-bresenham-s-line-generation
	 * 
	 * Wrapper to turn PathPoint into double[]
	 * 
	 * @param start PathPoint start of line
	 * @param end PathPoint of x, y, z end of line
	 * @return ArrayList<PathPoint> list of all rasterized and y-clamped PathPoint that lie on the line formed by start and end
	 */
	private ArrayList<PathPoint> rasterizePath(PathPoint start, PathPoint end)
	{
		return rasterizePath(start.x, start.y, start.z, end.x, end.y, end.z);
	}
	
	private ArrayList<PathPoint> rasterizePath(double[] start, double[] end)
	{
		return rasterizePath((int)start[0], (int)start[1], (int)start[2], (int)end[0], (int)end[1], (int)end[2]);
	}
	
	/**
	 * Checks if test is within 0.1 (1.1 in the case of y) of the destination
	 * @param test double[3] possible destination point
	 * @return true if within range, false otherwise
	 */
	private boolean isEnd(double[] test)
	{
		boolean isx = test[0] > destination[0] - 0.1 && test[0] < destination[0] + 0.1;
		boolean isy = test[1] > destination[1] - 1.1 && test[1] < destination[1] + 1.1;
		boolean isz = test[2] > destination[2] - 0.1 && test[2] < destination[2] + 0.1;
		
		return isx && isy && isz;
	}
	
	/**
	 * Clamp the y coordinate of a given position to the closest solid block below it (if air) or above it (if solid)
	 * double[] version
	 * @param point double[] point to clamp
	 * @return the clamped y value
	 */
	private int clampY(double[] point)
	{
		return clampY(point[0], point[1], point[2]);
	}
	
	/**
	 * Clamp the y coordinate of a given position to the closest solid block below it (if air) or above it (if solid)
	 * (x, y, z) version
	 * @param x
	 * @param y
	 * @param z
	 * @return the clamped y value
	 */
	private int clampY(double x, double y, double z)
	{
		int yl = (int)y;
		
		//If a point is obstructed, go up until it isn't
		if(isObstructed(x, yl, z))
		{
			while(isObstructed(x, yl, z) && yl++ < 257) {}
		}
		
		//Otherwise, go down until it is
		else
		{
			while(!isObstructed(x, yl, z) && yl-- > 0) {}
			yl++;
		}
		
		return yl;
	}
	
	/**
	 * Generate a new branch if there is no collision
	 * @param end
	 * @return boolean true if successful
	 */
	public boolean generateNextBranch(double[] end)
	{
		long time = System.currentTimeMillis();
		end[1] = clampY(end);
		timeClamp += System.currentTimeMillis() - time;
		
		time = System.currentTimeMillis();
		Branch closest = getClosestBranch(end);
		timeNN += System.currentTimeMillis() - time;
		
		time = System.currentTimeMillis();
		ArrayList<PathPoint> rasterized = rasterizePath(closest.getEnd(), end);
		timeRasterize += System.currentTimeMillis() - time;
		
		time = System.currentTimeMillis();
		boolean isValid = isValidPathSegment(rasterized);
		timeCollision = System.currentTimeMillis() - time;
		
		Branch branch;
		
		if(isValid)
		{
			branch = new Branch(closest.getEnd(), end, closest, rasterized);
			branches.add(branch);
			
			goalBranch = branch;

			hasSolution = isEnd(end);
			
			return true;
		}
		
		return false;
	}
	
	/**
	 * Returns the branch whose end is closest to the provided coordinates
	 * @param coord
	 * @return
	 */
	private Branch getClosestBranch(double[] coord)
	{
		Branch closest = root;
		
		double distance, closestDistance = Double.MAX_VALUE;
		
		for(Branch branch : branches)
		{
			double dx = branch.getEnd()[0] - coord[0];
			double dy = branch.getEnd()[2] - coord[2];
			
			distance = (dx * dx) + (dy * dy);
			
			if(distance < closestDistance)
			{
				closest = branch;
				closestDistance = distance;
			}
		}
		
		return closest;
	}
	
	/**
	 * A branch. Holds start position, end position, rasterized path, and parent
	 * @author kiraisuki
	 *
	 */
	private class Branch
	{
		private double[] start, end;
		private Branch parent;
		private ArrayList<PathPoint> pathSegment;

		public Branch(double[] start, double[] end, Branch p, ArrayList<PathPoint> segment)
		{
			this.start = new double[3];
			this.start[0] = start[0];
			this.start[1] = start[1];
			this.start[2] = start[2];
			this.end = new double[3];
			this.end[0] = end[0];
			this.end[1] = end[1];
			this.end[2] = end[2];
			parent = p;
			pathSegment = segment;
		}
		
		public ArrayList<PathPoint> getPathSegment()
		{
			return pathSegment;
		}
		
		public double[] getStart()
		{
			return start;
		}
		
		public double[] getEnd()
		{
			return end;
		}
		
		public Branch getParent()
		{
			return parent;
		}
	}
}
